1. INTRODUCTION

Poslin is short for "Postfiksa Lingvo" which is Esperanto and means
"postfix language". As is to be expected, poslin uses postfix
notation.

If you aren't familiar with the term: Postfix notation means that the
operator is written after the operands he is operating on. So, if you
want to translate 1+2 (which is written in infix notation) to postfix
notation you write
1 2 +

Why would that be useful?
Well, postfix notation is pretty easy to process for a
computer. Actually everything one needs for processing postfix is a
stack and knowledge of what an operator is. That means in postfix
notation you do the following: If you encounter something but an
operator, put it on the stack. If you encounter an operator, take as
much off the stack as the operation processes, call the operation on
the things you took off the stack and then put the result back onto
the stack.

Poslin has two kinds of operators: Those, which "know" they are
operators and act accordingly when they are encountered by poslin and
those which need to explicitely told that they are opartors by an
operation. The first kind is called "immediate", the second "delayed".

Immediate operators are intended to be used as part of the
syntax. They define how poslin code behaves.
Probably the most important immediate primary (meaning they are not
defined in terms of poslin code) operators are '!', '&', '[' and ']'.
'!' tells a delayed operator to get to work. So, to add two numbers
you have to write (ignoring the opening '>' as this is just a symbol
to indicate a prompt)
> 1 2 + !
because '+' is delayed and won't do anything by itself.
'&' takes an operator and returns it's thread. A thread in poslin has
got nothing to do with multithreading or processes but is the internal
representation of something that can be executed in poslin. A primary
operator is like an atomic thread, while operations defined in poslin
are more complex ones.
'&' is useful for defining new operators as those new operators need
to know which other operators to call at which point. We can't use '!'
for that purpose as we don't want to call those operators right now
but only later.
'[' and ']' are another specialty of poslin. Poslin doesn't work with
just one stack but with a whole stack of stacks. So, that stack of
stacks is called the "path". Anything that happens on a stack always
happens to the stack that is on top of the path. '[' creates a new
stack and pushes it onto the path, ']' pops off the top of the path
and then pushes it anto the new top of the path (that is, onto the top
of the stack that now is on top of the path).


2. A FIRST IMPRESSION

To give you an impression on how to write a program in poslin I will
give you an expample.
To follow the example, start up your poslin REPL.

First let's define an operation that takes one argument and squares
it.

> square {
[ROOT:SQUARE:]
This is how we start the definition of an operation: First the name,
then a '{', which is an immediate operator that does some bookkeeping
stuff. One thing it does is giving the newly opened stack the name
that is on top of the old current stack. That's why you see the
'SQUARE:' behind the 'ROOT:'.
Later in the tutorial you will define that operator yourself, just
like all the other non-primary operators used here.

> a arg
This tells the operator to take one argument named 'a'.
After typing this, you REPL might answer you like this:
[ROOT:SQUARE: A TH{ TH{ 1 OP{^} } OP{->} }
 TH{ OP{R<-} TH{ TH{ 0 OP{^} } OP{?EV} } TH{ TH{ 0 OP{^} } OP{<>} }
  OP{R->}
  TH{ OP{R<-} OP{B*} TH{ TH{ 0 OP{^} } OP{§} } OP{R->} OP{@B} OP{@BV}
  } }]
This is because 'arg' is an immediate operator that puts a few threads
on the current stack. Those threads are doing all the stuff necessary
to get a parameter off the stack and then save it locally under the
supplied name. This is what I meant when I said that immediate
operators are there for defining syntax.

> a &v
Gives code that will look for the value of 'a'.

> a &v * &
Get that code again and then put some code there to multiply the
numbers you will just have got.

> result
Nothing left but to return the value we just will have
calculated. This does what is necessary.

> }@
And with this the operation is defined.
Try it!
> 5 square !
[ROOT: 25]

Now enter
> __ !
To clean the current stack.


3. UNDERSTANDING THREADS

The stack you built up when defining 'square' probably looked very
intimidating. Still, being able to interpret threads can e quite
helpful, when debugging for example.
Now, something as big as 'square' is probably a bit much, so let's
start with something else instead.
> foo [ 2 + & ]@
This defines an operation foo without any extra bookkepping. One of
the tasks of '}@' is to wrap the compiled thread in code that will
open and close a new stack. ']@' does no such thing, so it operates on
the same stack it was called on. Conversely this means we cannot use
'args', or at least we cannot use it in the same way we used it in
'square'.

Let's try 'foo'.
> 4 foo !
[ROOT: 6]
What happens is this: Foo puts a 2 on the stack and then calls the
'+'. On the stack now are the numbers 4 and 2 and so the two are added
and the result 6 is put back onto the stack.
Now clean up, because threads are probably easier to read when there's
nothing else blocking our view.
> __ !
Now, get the thread of 'foo'.
> foo &
[ROOT: TH{ 2 OP{+} }]
That doesn't look too bad. The basic rule for interpreting a thread is
this: If you encounter a primary operator (of the form 'OP{...}'),
execute it's code. If you encounter a thread (of the form 'TH{ ... }')
put it onto the program counter while everything following it get's
pushed onto the return stack. How that works and how it is useful we
will see later. Anything else get's just pushed onto the current
stack.
So, the thread TH{ 2 OP{+} } first pushes 2 on the current stack and
then executes '+'. That was easy.

Now, let's look at another example.
> __ !
For this we redefine square to be a bit less daunting.
> square [ ~§ & * & ]@
> 3 square !
[ROOT: 9]
> __ !
Now, look at the thread of 'square':
> square &
[ROOT: TH{ TH{ TH{ 0 OP{^} } OP{§} } OP{*} }]
Now, this is a bit more complex and has three levels of threads.
Now, in the following table I will go through the thread step by
step. As anything on the program counter is surrounded by TH{ } I will
just skip that part in the table.

Current Stack		Program counter		        Return stack
4			TH{ TH{ 0 OP{^} } OP{§} } OP{*}
4			TH{ 0 OP{^} } OP{§}		OP{*}
4			0 OP{^}	      			OP{*} OP{§}
4 0			OP{^}				OP{*} OP{§}
The '^' primary operator takes one number off the current stack and
returns the nth stack on the path. So, the zeroe's stack on the path
is the current stack.
4 [ ]							OP{*} OP{§}
Now the Program counter is empty, so we pop the top of the return
stack and put it into the Program counter.
4 [ ] 	      	      	OP{§}				OP{*}
'§' takes a stack as it's argument and duplicates it's top. The [ ] up
there is our current stack and if '§' consumes one argument and then
duplicates the top, 4 will be duplicated on the current stack.
4 4							OP{*}
4 4			OP{*}
16
Both the Program counter and the return stack are empty, so our
calculation is done and we have seen how 'square' does its work.
> __ !

Just to give you an idea where the inner threads came from:
> ~ &
[ROOT: TH{ 0 OP{^} }]
'~' pushes the current stack onto itself. This operator exists because
alle stack manipulating primary operators take a stack as an argument
from the current stack but we often need to manipulate the current
stack (especially when writing the standard library).
> __ !

> ~§ &
[ROOT: TH{ TH{ 0 OP{^} } OP{§} }]
The first element in the thread is the thread that w have just seen -
the one giving back the current stack. The second element in the
thread is the operator that duplicates the top of the given
stack.

Now let's look at some of the words used earlier.
> result
[ROOT: TH{ TH{ 1 OP{^} } TH{ TH{ 0 OP{^} } OP{<>} } OP{<-} }]
'result' obviously is immediate.
It gets the parent stack (TH{ 1 OP{^} }), then gets swaps on the
current stack (TH{ TH{ 0 OP{^} } OP{<>} }) and then pushes whatever
was on top before onto the parent stack (OP{<-}).
Basically 'result' inserts code that pushes the top of the current
stack onto the parent stack. So, if we want to use it to return some
value from an operation, that operation needs to open it's own stack.


4. ENVIRONMENTS AND BINDINGS

Poslin stores operations and variables in bindings. A binding is a
structure that holds a value and a documentation string. Those
bindings are first class values. That means, you can operate on them
directly, like on numbers, stacks or threads.
To get the value of a binding you can use '?b', to get its
documentation string use '?d'. Setting is done with '@b' and '@d'
respectively.
Bindings alone aren't that useful. To make them useful you also need
environments.
An environment can be understood as a container or a map that
associates symbols with bindings.
A lexical environment is an environment that also has a parent
environment. If you can't associate some symbol in the environment
itself, look it up in the parent environment!
Poslin uses 2 types of lexical environments: one for storing the
values of variables, one for storing the threads associated with
operation names. The first type is called a 'variable environment',
the second one an 'operation environment'. Operation environments
*also* keep track whether a certain symbol is taken to be immediate or
delayed.
Any stack is associated with exactly one operation and one variable
environment. '!' and '&' look up operations, when given a symbol, in
the operation environment of the current stack (the current operation
environment). '?eo' and '?ev' return the respective environment of a
given stack while '@eo' and '@ev' set it.
To get a binding out of an environment, use '?bo' and '?bv'
respectively. The setting operations are '@bo' and '@bv'. '@bo' is a
bit special, as it automatically converts the value of the binding it
is storing to a thread.
To make a child operation environment of an existing environment you
can use 'eo+' and 'ev+'

What is all of this good for?
Having environments as first class objects is quite handy.
In several high level languages one has some kind of word like 'let'.
For example in Common Lisp one can say
(let ((la 4)
      (di 6)
      (da 8))
  ...)
and that opens up a new lexical environment in which the variables
'la', 'di' and 'da' are defined. Poslin has no let, but when we have
control over environments either way, we can define it ourselves (and
we will do just that).
We can also define operations in a way so that operation environments
can act as packages (which are just collections of operations, which
is the sole purpose of an operation environment either way).

The standard library defines a few more operators that handle
operations. Normally, to get to the value of a variable, one would
have to do the following things while keeping everything in the right
order:
- Get the current stack
- Get its variable environment
- Get the binding associated with the given name
- Get the value out of that binding
This is really too much for the given task. That's why '?~v' and '?~o'
exist.
Setting is a bit more complex, as with lexical environments when
setting something you have two choices: Set in the current environment
without affecting parent environments or set in a way so that the
currently defined place changes. The first is necessary when opening
up a local environment to have local definitions, the second (for
example) when setting a value in a closure.
'@~o*' and '@~v*' always create a new binding while '@~o' and '@~v'
use an existing binding when there is one.

Suppose you want a function that counts how often it has been
called. In Common Lisp you would write
(let ((count 0))   ; open a new lexical environment containing the
     	     	   ; variable COUNT initialized to =
  (defun count ()  ; define the function COUNT
    (incf count))) ; COUNT increases COUNT by one and returns the new
    	  	   ; value
A version in poslin could be defined like this:
First, open up a new stack that has it's own operation environment.
> v[

Define the local variable count to be 0. 'let' is an immediate version
of '@~v*', so it makes sure that no previously existing definition of
'count' is changed.
> count 0 let

Open up the definition for the operation.
> count {

We now need to get the variable 'count' and increase it by one.
'&@v' immediately inserts code for setting a variable (the same way
that '@~v' does, so we will modify the previously defined 'count'
here). The brackets '~[' and '~]' are purely cosmetic and don't do
anything. They just give a visual clou about what belongs to
what.
> count ~[ count &v 1 + & ~] &@v
The inner group is where we get the value and increase it by one. The
outer call (occuring later because '@~v' is encountered after the
inner group) then sets the already defined 'count' to count+1.
NOTE: '~[' and '~]' don't need to be balanced and they don't change
      how your program works in any way. That means writing something
      in those brackets doesn't make sure that the operations within
      don't consume anything from the outside. Like comments they
      don't do anything at all. They are both immediate symbols whose
      associated operation doesn't do anything.

Finally we need to return the newly achieved value.
> count &v result

Define the operation. We need to use '}@' for that so the operation
will use a stack that carries the local variable environment where our
count is defined! If we used ']@' the local environment opened with
'v[' would be lost as soon as we closed it and our operator wouldn't
have any knowledge of it.
> }@

Now that we have defined the operation we don't need our stack with
it's local variable environment anymore, so we can close and discard
it.
> ]_

It should work like this:
> count !
[ROOT: 1]
> count !
[ROOT: 1 2]
> __ !
> count !
[ROOT: 3]
> __ !


5. IF AND RECURSION

Forth uses 'branch-if' to implement 'if' in a way that looks more like
a usual 'if'. This has the downside that 'if' only works in a
thread. Poslin basically can do the same, but having no conditional
available in the REPL would be quite inconvenient.
That's why poslin has '<?>'. This operation takes 3 arguments off the
stack. If the leftmost is 'nil' the rightmost argument is put back
onto the stack, if it is something else the middle argument is put
back.
> nil a b <?> !
[ROOT: B]
> __ !
> t a b <?> !
[ROOT: A]
> __ !

This alone doesn't look all that useful. Normally one would like to
execute some code after branching.
You can do it like this:
> 3 t [ 2 * & ] [ 2 + & ] <?> ! !
[ROOT: 6]
> __ !
> 3 nil [ 2 * & ] [ 2 + & ] <?> ! !
[ROOT: 5]
> __ !

Basically you put the code to execute on it's own stack and then
choose which stack to call.

There is one other problem in poslin. Poslin doesn't have recursion or
looping built in. When an operation is defined we cannot put it's own
thread on itself because that thread is not known at the time.
Thus, when we want recursion, we need to look up the definition of the
operation at runtime. This we can do by putting the thread of '!' on
the stack instead of putting the thread of what we want to call on the
stack.
Now, when you want the thread of an immediate operation you can't just
write it like you usually would because then poslin would try to call
the immediate operation and that might have unforeseen consequences.
To prevent something from being looked up, quote it like this:
> '!
[ROOT: !]
Note that, when doing that with a delayed symbol, this is equivalent
with just writing the symbol itself.
We now can get the thread of '!'
> &
[ROOT: OP{!}]
> __ !
Because this is something we need to do more often there is an
immediate operator that returns the thread of '!'. It is called '!&'.
In the same way when recursing we will often need 'OP{<?>} OP{!}' on
our stack, so there is an immediate operator for that, too: '<?>!'.

The factorial function is a must when writing a tutorial and doing
recursion, so here it is:
> fact
> { n arg
>   n &v 1 <= &  ; n<=1
>   1 	      	 ;    1
>   [ n &v 1 - & ;    n-1
>     fact !&    ;    (n-1)! ; a recursive call with !&
>     n &v * &	 ;    (n-1)!*n
>   ]
>   <?>!	 ; if n<=1 then 1 else (n-1)!*n and then calculate!
>   result	 ; return the result
> }@
> 5 fact !
[ROOT: 120]


6. THAT'S IT FOR NOW

This part of the poslin tutorial covered:
- postfix notation
- the basics of defining operations in poslin
- what threads in poslin are
- what environments and bindings in poslin are
- how to use conditionals and do recursion

In the next part all of the standard library will be thrown out and I
will show you how to implement it from scratch.
The first few definitions will be quite hard to understand as there
will be no syntactic sugar at all. Hopefully this helps you understand
poslin better and give you some idea on how to extend it beyond what I
could think of.
