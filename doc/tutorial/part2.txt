1. STARTING UP

For the last part you probably started up the standard REPL of
poslin. The standard REPL automatically loads the standard library. As
I want to show you how to implement the standard library yourself,
this is not really desirable right now, so instead of loading "poslin"
with quicklisp, load "poslin-tutorial" and then instead of typing
(poslin:repl)
to start the repl, type
(poslin-tutorial:repl2)
Congratulations! You now don't have any syntactic sugar, helpful
shortcuts or any kind of convenience in your REPL.


2. CURRENTLY

Right now the operations available to you are quite limited. If you
messed up your stack now (for example) it will be unbearably hard to
clean it up again.
Before you would have just typed
> __ !
But '__' is defined in the standard library so we cannot do that.
All primary operations manipulating stacks do not manipulate the
current stack but on the stack that is on top of the current stack, so
that's not so nice, too.
As manipulating the current stack is quite important we first might
want to take care of that.
Also we don't have any operations to help with our bookkeeping, so
this isn't going to be easy. Getting some sugar for bookkeeping is
also very important (we will want to be able to actually read the code
we write), so this will be our first bigger task.

Let's start with an operation that gives us back the current stack. To
define an operation we need
- the operation environment in which the operation should be
  accessible
- a name for the operation
- a binding
- a thread

The environment we want is the current operation environment or, more
precisely, the operation environment of the current stack.
So we first need the current stack. As you might remember the current
stack is the zeroeth stack on the path and the nth stack on the path
we get with 'n ^ !', so what we need is
> 0 ^ !
And of that we want the operation environment. To get the operation
environment of a stack, use '?eo'.
> ?eo !
Next up is the name of our operation. The convention I chose is, that
anything explicitely related to the current stack is marked with a
'~', so that is going to be the name for the current stack.
> ~
We don't do anything with the name right now.
Now to the binding. A binding we get with 'b*'.
> b* !
We will later set that binding. Setting a binding consumes said
binding and then it is lost. Losing our binding would be terrible as
then we had no way of getting it back. We need our binding twice: Once
for setting it's value and then for storing it in the operation
environment, so we duplicate it.
Duplication modifies a stack and as said those operations consume a
stack object, so we need to get the current stack again before
duplicating it's top with '§'.
> 0 ^ !
> § !
This works because '§' first consumes the top of the current stack and
only *then* duplicates.
Now we have everything in order, so we can start defining our
operation. For this, open a new stack on the path.
> [
The whole 'get the current stack' thing we now did twice, so you
hopefully have an idea how to do it. You only need to remember that
now you don't want to actually get the current stack but the operation
for getting the current stack.
> 0 ^ &
Now, close that stack, it has everything it needs.
> ]
The only thing left to do is storing the stack and then storing the
binding. As storing a binding in an operation environment
automatically converts the bindings value to a thread, there is no
need to do this by hand.
> @b !
> @bo !
You should now be on the root stack, which should be empty.
Now, testing is an important thing to do, so do it.
> ~ !
To drop the top of the current stack (so it is empty again for writing
the next definition) write
> ~ ! _ !

When defining a new function we always want to do so in the current
operation environment. So we always need to first get the current
operation environment. That means there probably should be an
operation to get the current operation environment. It is sensible to
put that operation into the current operation environment, which we
get with
> ~ ! ?eo !
There it is!
Now we need a name. '~' was for 'current', '?' is for get and 'eo' is
for 'operation environment', so to express 'get current operation
environment' I use '?~eo'.
> ?~eo
Again we need one binding for setting and storing.
> b* ! ~ ! § !
so we can start defining.
> [
To get the current operation environment we get the current stack and
extract it's operation environment.
> ~ & ?eo &
And that's it. Do the usual bookkeeping so you can use the fruits of
your hard work later.
> ] @b ! @bo !
You might want to test what you just defined.

We were doing a lot of duplication lately, and all on the current
stack. That's much too much duplicate work, so write an operation to
do that work for you and save as much as 3 keystrokes (2 spaces and 1
'!') per duplication.
> ?~eo !
> ~§
> b* !
> ~ ! § !
> [ ~ & § &
> ] @b ! @bo !


2. DEFINITION

Defining all that stuff was a lot of work. Handling those bindings per
hand is probably something you don't want to do in most cases, so it
meight be sensible to write an operation that automatically constructs
the needed binding and does all the duplication and storing and stuff
for itself.
Now, writing that kind of operation isn't trivial, as postifx demands
from us that we do stuff in a certain order. As you have seen we first
need to place the operation environment and then we need the name and
then the bindings and only then comes the stack that holds our
definition. The convention for operations that do some kind of storing
something somewhere else is like this in poslin:
where what store !
This means when encountering something like this the operation that
does the storing needs to shuffle stuff around on the stack. One can
easily loose track when writing code that shuffles stuff around, so it
can be quite useful to have some notation that shows what's going on.
First we need to show what we actually want to happen on the stack,
that means, how should the stack look *before* we call our operation
and how we want it to look *after* it has been called.
The following format is quite nice for that purpose:
( before -- after )
The first defining operation we want to define has the following
signature:
( operation-environment name operation-definition -- )
Note that the operation itself doesn't show up.
Poslin has one-line comments. Those comments always start with
';'. Use them! Self documenting code really is very nice, but right
now poslin doesn't have it because we are currently in the process of
implementing it.

The first operation to implement is '@o*'. This operation sets ('@')
in an operation environment ('o') a new binding ('*').
> ?~eo !
> @o* ; ( op-env name op-def -- )
> b* ! ~§ !
> [
To have an idea of what's going on just write a comment to the right
of each line that shows how the stack looks after applying the current
line to how the stack looked before.
It is now necessary to insert two bindings in front of what I called
'op-def'. For this purpose I first need to temporarily get rid of
'op-def'.
Poslin gives you access to the return stack. The purpose of the return
stack is to keep track of where to return to after an operation call
is done. As long as we clean up after ourselves before returning from
an operation we normally can (mis)use the return stack to temporarily
keep data out of our way. To push something onto the return stack, use
'r<-', to pop something off the return stack, use 'r->'.
> r<- & ; op-env name ; op-def
What I put on the return stack is seen to the right of the second
semicolon.
Now I can insert my binding and duplicate it without any trouble.
> b* & ~§ & ; op-env name binding binding ; op-def
> r-> &     ; op-env name binding binding op-def
> @b &      ; op-env name binding
> @bo &	    ;
And with that the operation doesn everything we want it to, so the
stack can be closed and the operation defined.
> ] @b ! @bo !

Next up is defining something in the current operation environment
('@~o*') but first we need to be able to swap on the current stack
conveniently ('~<>').
> ?~eo !
> ~<>    ; ( val1 val2 -- val2 val1 )
> [ ~ &  ; val1 val2 [ ... val1 val2 ]
>   <> & ; val2 val1
> ] @o* !

> ?~eo !
> @~o* ; ( name op-def -- )
This signature looks almost like that of '@o*', only the 'op-env' in
front is missing. Put it there and we can use '@o*'.
> [ r<- &  ; name ; op-def
>   ?~eo & ; name op-env ; op-def
>   ~<> &  ; op-env name ; op-def
>   r-> &  ; op-env name op-def
>   @o* &  ;
> ] @o* !

From now on a defintion looks like this:
foo
[ bar ] @~o* !
This is a lot shorter and clearer than what we did at the start:
0 ^ ! ?eo ! foo b* ! 0 ^ ! § !
[ bar ] @b ! @bo !
Also the name of the defined operation is now much easier to see.

It is possible to make this even shorter, as you might remember from
the first part of the tutorial.
The operator I am talking about is ']@'. First off, ']@' will be
immediate (it isn't right now because it hasn't been defined yet and
the operation environment doesn't know anything about that symbol at
all).
> ]@     ; ( name [ ... -- )
> [ '] & ; name [ ... ]
']' already *is* immediate (as you might have noticed) because it is a
primary operation that is defined to be immediate in the core of
poslin. That's why we need to put a ' in front of it.
>   @~o* & ;
> ] @~o* !
If you were to try out ']@' now it wouldn't work. The problem is that
it isn't immediate, so you still would need to write
]@ !
This is not what we want. For that purpose we use the operator '@i'
like this:
> ?~eo ! ]@ t @i !
It needs to know in which operation environment the symbol should be
immediate, what symbols immediateness to set and whether it should be
immediate (signaled with 't') or delayed (signaled with 'nil').
So finally ']@' is immediate.


3. WHAT BINDINGS ARE GOOD FOR

Till now bindings have mostly been a nuisance. A lot of hassle could
have been spared if we would have been able to just set a thread in an
environment instead of needing to wrap it in a binding beforehand.

Bindings serve two purposes:
First, when looking up a symbol in an environment you either get back
a binding or you get back 'nil'. Getting back 'nil' is a foolproof way
to know that the symbol actually has no associated value. If it's
associated value is 'nil' you will get back a binding whose value is
'nil'.
Second when just setting a value in the environment instead of setting
it in a binding there is no way to overwrite a binding of a symbol
that was established in an ancestor of the environment you are working
in. Speaking in Common Lisp that means that without using bindings
(let ((x 5))
  (let ((y 6))
    (setf x 3))
  x)
=> 5 ; not actually what evaluating this in Common Lisp would return
because the inner SETF created a new variable X in the inner lexical
environment. Most likely this is not what is intended and it is
certainly not what I would want as this behaviour makes creating
closures a lot harder and code like
(let ((x 0))
  (defun count-by (y)
    (incf x y)))
even impossible, as a function like COUNT-BY creates it's own lexical
environment which would make the X defined outside inaccessible for
setting.

The operations '@o*' and '@~o*' work like there are no bindings, so
they do not set already defined variables in an ancestor environment
but instead always create a new binding. This is what we probably want
when defining an operation, that's why we use '@~o*' in the definition
of ']@'.
It is still imaginable that we want to dynamically redefine an
existing function (maybe when doing memoization?) in what context
whatsoever, so we need the operations '@o' and '@~o' which respect
existing bindings.

> @o            ; ( op-env name op-def -- )
> [ r<- & r<- & ; op-env ; name op-def
>   ~§ &      	; op-env op-env ; name op-def
This is done because we need the operation environment for two
purposes in this operation: Once for looking for a possibly existing
binding and once for setting a new binding, if the old one doesn't
exist already.
>   r-> & ~§ &  ; op-env op-env name name ; op-def
The same goes for the name: Once for getting the binding, once for
maybe later setting a new binding when there isn't an old binding to
update.
>   r<- &	; op-env op-env name ; name op-def
>   ?bo &	; op-env binding? ; name op-def
Now we know whether we already have a binding or not. Now we branch,
so we put two stacks here: One for evaluating when a binding has been
found, and one in the case no binding has been returned. As the
binding will get consumed by checking we need to duplicate it first.
>   ~§ &     	; op-env binding? binding? ; name op-def
Here is what to do when a binding has been found:
>   [ r-> &	; op-env binding? name ; op-def
>     ~ & _ & 	; op-env binding? ; op-def
We already have a binding and we don't need a new one, so we just drop
the name. We would only need it when setting a new binding.
>     r-> &  	; op-env binding? op-def
Now we need to convert the operation definition into a thread. As we
won't call '@bo' to set the binding explicitely this won't happen
automatically as it did when we defined '@o*'.
>     '& &    	; op-env binding? thread
>     @b &	; op-env
Now the binding has the new value and we don't need the operation
environment anymore, so we discard it.
>     ~ & _ &	;
>   ]
>   [ ~ & _ &	; op-env ; name op-def
'binding?' is 'nil' either way, so there is no point in keeping it.
>     r-> &   	; op-env name ; op-def
>     r-> &	; op-env name op-def
>     @o* &	;
>   ]
>   <?> & '! &
> ]@

'@~o' will be a breeze now.
> @~o      ; ( name op-def )
> [ r<- &  ; name ; op-def
>   ?~eo & ; name op-env ; op-def
>   ~<> &  ; op-env name ; op-def
>   r-> &  ; op-env name op-def
>   @o &   ;
> ]@


4. THATS IT FOR NOW

I showed you how to implement basic syntactic sugar for defining the
most basic kind of operations. I also covered why bindings exist and
how they are used.
In the next part operations for setting immediateness will be
covered. I will also show you how to make use of local environments,
what purpose curly braces fullfill and how they are implemented.
